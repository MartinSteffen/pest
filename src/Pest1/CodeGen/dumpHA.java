/**
 * dumpHA
 *
 * This class is responsible for generating our hierarchical
 * automaton.
 *
 * @version $Id: dumpHA.java,v 1.4 1999-01-04 15:20:18 swtech25 Exp $
 * @author Marcel Kyas
 */
package codegen;

import absyn.*;
import java.io.*;
import java.util.*;

public class dumpHA
{
	private final float loadFactor = (float) 0.7;
	private Statechart S;
	private String path;
	private int state_curr_key = 0;
	private int event_curr_key = 0;
	private int cond_curr_key = 0;
	private Hashtable states_key = new Hashtable(1024, loadFactor);
	private Hashtable states_sym = new Hashtable(1024, loadFactor);
	private Hashtable events_key = new Hashtable(1024, loadFactor);
	private Hashtable events_sym = new Hashtable(1024, loadFactor);
	private Hashtable cond_key = new Hashtable(1024, loadFactor);
	private Hashtable cond_sym = new Hashtable(1024, loadFactor);

	/**
	 * This will construct a dumb instance of dumpHA.  You will
	 * need to set the state chart seperately.
	 */
	public dumpHA()
	{
		S = null;
		path = null;
	}


	/**
	 * This will construct some instance of dumpHA and will initialize
	 * its state chart with bla.
	 */
	public dumpHA(Statechart bla)
	{
		path = null;
		setStatechart(bla);
	}


	/**
	 * This will construct some instance of dumpHA and will initialize
	 * its path name with bla.
	 */
	public dumpHA(String bla)
	{
		S = null;
		setPathname(bla);
	}


	/**
	 * This will construct some instance of dumpHA and will initialize
	 * its state chart with bla and the path name to fasel.
	 */
	public dumpHA(Statechart bla, String fasel)
	{
		setStatechart(bla);
		setPathname(fasel);
	}


	/**
	 * Set statechart to bla.
	 */
	public void setStatechart(Statechart bla)
	{
		try {
			S = (Statechart) bla.clone();
		}
		catch (CloneNotSupportedException e) {
			// currently nothing.
		}
	}


	/**
	 * Set path to bla.
	 */
	public void setPathname(String bla)
	{
		path = bla;
	}


	/**
	 * Creates symbol names PathList and hashes them in Table.
	 */
	private void generateStateTable()
	{
		PathList current;
		Path name;
		String symbol;
		Integer key;

		current = S.cnames;
		while (current != null) {
			name = current.head;
			symbol = new String(name.head);
			name = name.tail;
			while (name != null) {
				symbol += ("_" + name.head);
				name = name.tail;
			}
			// put them into Hash table, but check first.
			if (!states_key.containsKey(symbol)) {
				key = new Integer(state_curr_key);
				states_key.put(symbol, key);
				states_sym.put(key, symbol);
				state_curr_key++;
			}
			current = current.tail;
		}
	}


	/**
	 * Creates symbol names PathList and hashes them in Table.
	 */
	private void generateEventTable()
	{
		SEventList current = S.events;
		Integer key;

		while (current != null) {
			// put them into Hash table, but check first.
			if (!events_key.containsKey(current.head)) {
				key = new Integer(event_curr_key);
				events_key.put(current.head, key);
				events_sym.put(key, current.head);
				event_curr_key++;
			}
			current = current.tail;
		}
	}


	/**
	 * Creates symbol names PathList and hashes them in Table.
	 */
	private void generateCondTable()
	{
		BvarList current = S.bvars;
		Integer key;

		while (current != null) {
			// put them into Hash table, but check first.
			if (!cond_key.containsKey(current.head)) {
				key = new Integer(cond_curr_key);
				cond_key.put(current.head, key);
				cond_sym.put(key, current.head);
				cond_curr_key++;
			}
			current = current.tail;
		}
	}


	/**
	 * In this section we will generate a symbol table.
	 *
	 * @exception CodeGenException if a code generation error
	 *	was encountered.
	 * @exception IOException What shall we say?
	 */
	private void dumpSymbolTable(OutputStreamWriter f)
		throws CodeGenException, IOException
	{
		final String[] state_head = {
			"static final String[] statenames = {"
		};

		final String[] state_tail = {
			"}"
		};

		final String[] event_head = {
			"static final String[] eventnames = {"
		};

		final String[] event_tail = {
			"}"
		};

		final String[] cond_head = {
			"static final String condition_names = {"
		};

		final String[] cond_tail = {
			"}"
		};

		final String[] head = {
			"/**",
			" * This code was automatically generated by codegen",
			" */",
			"public class SymbolTable {"
		};

		final String[] tail = {
			"boolean[] pre_states = new boolean[statenames.length];",
			"boolean[] post_states = new boolean[statenames.length];",
			"boolean[] pre_events = new boolean[eventnames.length];",
			"boolean[] post_events = new boolean[eventnames.length];",
			"boolean[] pre_cond = new boolean[condition_names.length];",
			"boolean[] post_cond = new boolean[condition_names.length];",

			"}"
		};

		int i;

		/* do the magick */
		for(i = 0; i < head.length; ++i) {
			f.write(head[i]);
		}
		for(i = 0; i < head.length; ++i) {
			f.write(state_head[i]);
		}
		// dump states
		for(i = 0; i < head.length; ++i) {
			f.write(state_tail[i]);
		}
		for(i = 0; i < head.length; ++i) {
			f.write(event_head[i]);
		}
		// dump events
		for(i = 0; i < head.length; ++i) {
			f.write(event_tail[i]);
		}
		for(i = 0; i < head.length; ++i) {
			f.write(cond_head[i]);
		}
		// dump conditions
		for(i = 0; i < head.length; ++i) {
			f.write(cond_tail[i]);
		}
		for(i = 0; i < head.length; ++i) {
			f.write(tail[i]);
		}
	}

	/**
	 * In this section we will generate the new
	 * events.
	 *
	 * @exception CodeGenException
	 */
	private void dumpNewEvents() throws CodeGenException
	{

	}

	/**
	 * This method will dump the hierarchical automaton
	 *
	 * @exception CodeGenException
	 */
	void dump() throws CodeGenException
	{
		generateStateTable();
		generateEventTable();
		generateCondTable();
	}
}
