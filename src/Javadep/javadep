#! /bin/sh

# javadep findet und listet alle Abhängigkeiten von Paketen auf.
#
# Für ein Paket sind die Abhängigkeiten dieses Pakets die
# Abhängigkeiten der einzelnen Klassen.
#
# Für eine Klasse sind die potentiellen Abhängigkeiten alle
# öffentlichen Klassen von importierten Paketen.

# 1. Für eine angegebenes Paket:
# -- Alle Klassen-Dateien nach import-Anweisungen durchsuchen
# 2. Für alle importierten Pakete;
# -- Alle public-Klassen im des Pakets finden
# -- Nach Vorkommen dieser Klassen und Methoden in allen Dateien der
#    Klasse suchen.
###########################################################################
display_usage()
{
echo "
Usage: javadep [options] packagename|java-file
Where options are:
 -h         Display this help.
 -t         Produce text-output rather than html-code
 -o file    Output to file
"
}
###########################################################################
error()
{
  echo -e "ERROR: $*" >/dev/stderr
}
###########################################################################
warning()
{
  echo "WARNING: $*" >/dev/stderr
}
###########################################################################
log()
{
  if [ $verbose = 1 ]; then
    echo "$*" >/dev/stderr
  fi
}
###########################################################################
templog()
{
  echo "$*" >> $tempfile
}
###########################################################################
listrefs()
{
  read ref
  while [ $? = 0 ]; do
    echo "<li> $ref </li>"
    read ref
  done
}
###########################################################################
split_at_char()
{
# erhält als erstes Argument das neue Trennzeichen
# Die weiteren Argumente werden bei diesem Zeichen getrennt und als
# Liste einzelner Argumente zurückgegeben

  if [ $# -lt 2 ]; then
    error "split_at_char called incorrectly."
    return 1
  fi

  (
    IFS=$1
    shift
    echo $*
  )
}
###########################################################################
find_path_dirs()
{
  if [ $# != 1 ]; then
    error "find_path_dirs called incorrectly."
    return 1
  fi
  path=`(split_at_char ":" $1)`
  
  
  for i in $path; do
    if [ -d $i ]; then
      echo $i
    fi
  done
  echo $result
}
  
###########################################################################
find_package_dir()
{
  if [ $# != 1 ]; then
    error "find_package_dir called incorrectly."
    return 1
  fi
  package=$1
  result=
  if [ ! -z $CLASSPATH ]; then
    class_dirs=`(find_path_dirs $CLASSPATH)`
    for i in $class_dirs; do
      if [ -d $i/$package ]; then
        if [ "$result" != "" ] && [ $result != $i/$package ]; then
          warning "Multiple occurences of $package in CLASSPATH"
          log "  $result"
          log "  $i/$package"
        else
          result="$i/$package"
        fi
      fi
    done
    if [ "$result" = "" ]; then
      return 1
    else
      echo "$result"
    fi
  else
    error "CLASSPATH not set"
    return 1
  fi
}
###########################################################################
find_package_files()
{
  if [ $# != 1 ]; then
    error "find_package_files called incorrectly."
    return 1
  fi

  package=$1
  package_dir=`(find_package_dir $package)`
  if [ "$package_dir" = "" ]; then
    error "package directory not found: $1"
    return 1
  else
    files=`find $package_dir -type f -name "*.java" -exec grep -lw "package $package" {} \;`
#    files=`(grep -l "package $package;"  $package_dir/*.java) 2>/dev/null`
    echo $files
  fi
}
###########################################################################
find_public_functions()
{
# sucht alle public-Funktionen eines Paketes, die dem Pattern in $1
# entsprechen 

  if [ $# != 1 ]; then
    error "find_public_functions called incorrectly."
    error "$*"
    return 1
  fi

  set -f
  set `split_at_char "." $1`
  set +f  

  package=$1
  package_files=`(find_package_files $package)`
  if [ "$package_files" = "" ]; then
    error "No files found for $package"
    return 1
  fi
  functions=`grep -hw "public.*(" $package_files`
  echo "$functions"
}
###########################################################################
find_function_names()
{
 (
  # liest zeilenweise aus stdin und sucht in jeder Zeile 
  # (Java-Deklaration, die mit public... beginnt) nach dem
  #  Funktionsnamen
  read line
  org_line=$line
  while [ $? = 0 ]; do
    IFS="(" 
    set $line
    line=$1
    IFS=" "
    set $line
    if [ $# -gt 1 ]; then
      while [ $# != 1 ]; do
        shift
      done
      echo "$1"
    else
      error "Could not determine function name in: org_line"
    fi
    read line
  done
 )
}
###########################################################################
find_deps()
{
  javafile=
  if [ $# != 1 ]; then
    error "find_deps called incorrectly"
    return 1
  fi

  docudir=`find_package_dir pestdocu`
  if [ $? != 0 ]; then
    warning "Could not find pestdocu."
    docu_installed=0
    ref_installed=0
  else
    docu_installed=1
    ref_file=$docudir/AllNames.html
    if [ -f $ref_file ]; then
      ref_installed=1
    else
      ref_installed=0
    fi
  fi

  
  if [ -f $1 ]; then
    javafile=$1
    #Versuche package-Namen herauszufinden
    package=`grep -w "^package .*;" $javafile|awk '{printf $2}'`
    if [ "$package" = "" ]; then
      error "Could not determine package name"
      return 1
    else
      package_files=$javafile
    fi
  else
    # erstmal alle Dateien des Packages finden
    package=$1
    package_files=`find_package_files $package`
    if [ "$package_files" = "" ]; then 
      warning "No files found for package $package"
      return 1
    fi
  fi

  if [ $html = 1 ]; then
    if [ "$javafile" = "" ]; then
      templog "<h1> Dependencies in package <em>$package</em> </h1><br>"
    else
      templog "<h1> Dependencies in file <em>$javafile</em> </h1><br>"
    fi
  fi

  # Dateien mit import-Anweisungen finden
  all_imports=`grep -hw "import .*;" $package_files|grep -v "^//"`
  all_imports=`echo $all_imports|sed 's/import//g'|sed 's/;//g'|sed 's/\013//g'`

  
  # Imports zeilenweise ausgeben und mit sort -u doppelte Einträge
  # entfernen
  all_imports=`(for i in $all_imports; do
                  echo $i;
                done )|sort -u`

  if [ $html = 1 ]; then
    if [ "$javafile" = "" ]; then
      templog "<h2> List of all imports in package <em>$package</em><br>" 
    else
      templog "<h2> List of all imports in file <em>$javafile</em><br>" 
    fi 
    templog "<UL>" 
    for import in $all_imports; do
      templog "<LI>$import</LI>" 
    done
    templog "</UL>"
  else
    if [ "$javafile" = "" ]; then
      templog "List of all imports in package $package" 
    else
      templog "List of all imports in file $javafile" 
    fi 
    for import in $all_imports; do
      templog "+ $import" 
    done
  fi

  new_imports=
  for import in $all_imports; do
    set -f
    set `split_at_char '.' $import`
    import_package=$1
    
    if [ "$import_package" = "java" ] || [ "$import_package" = "com" ]; then
      log "Ignoring $import"
    else
      new_imports="$new_imports $import"
    fi
  done
  set -f
  all_imports="$new_imports"

  set +f

  templog "<h2>External functions and their occurences</h2>"
  for import in $all_imports; do
    set -f
    set `split_at_char '.' $import`
    set +f
    import_package=$1
    new_imports=
    # alle Funktionen des importierten Packets finden und nach
    # Vorkommen in den Files des zu untersuchenden Pakets finden 
    package_functions=`(find_public_functions $import)`
    if [ $? != 0 ]; then
      warning "No files for import $import found."
      continue
    fi
    function_names=`echo "$package_functions"|find_function_names|sort -u`

    #jetzt in allen Files des Packages nach diesen Funktionen suchen
    for function_name in $function_names; do
      if [ "$function_name" = "clone" ]; then
        continue
      fi
      if [ "$javafile" = "" ]; then
        uses=`grep -nw "$function_name\W*(" $package_files|awk -F: '{print $1 ":" $2}'`
      else
        uses=`grep -nw "$function_name.*(" $package_files|awk -F: '{print $1}'`
      fi
      if [ "$uses" != "" ]; then
        templog "<h3>$function_name</h3>"
        templog "Declaration(s) found:<br>"
        if [ $html = 1 ]; then
          if [ $ref_installed = 1 ]; then
            templog "<ul>"
            ref=`grep "href=\"$import_package\..*\#$function_name(" $ref_file|listrefs>>$tempfile`
            templog "</ul>"
          fi 
        else
          templog "$import_package.$function_name" 
          templog "===========================================" 
        fi

        templog "Occurences of $function_name:<br>"
	templog "<ul>"

        if [ "$javafile" = "" ]; then
          for i in $uses; do 
	    set `split_at_char : $i`
	    oc_file=$1
            oc_line=$2
             templog "<li> in file <a href=\"file://localhost$oc_file\">`basename $oc_file`</a>"
             templog "at line $oc_line </li>"
          done
        else
          for i in $uses; do echo "$javafile:$i">>$tempfile; done
        fi
	templog "</ul>"
      fi       
    done
  done
  templog "</ul>"
}
###########################################################################
tempfile=/tmp/javadep.$$
verbose=1
html=1
outfile=
args=

while [ $# != 0 ]; do
  case $1 in
	-h) display_usage
	    exit 0
	    ;;

	-t) html=0
	    shift
	    ;;

	-o) if [ "$2" != "" ]; then
              outfile=$2
            else
              echo "No outputfile after -o."
              exit 1
            fi
	    shift
            shift
	    ;;

	-*) echo "Unknown option: $1"
	    display_usage;
	    exit 1
	    ;;

	 *) args="$args $1"
            shift
	    ;;
  esac
done


if [ -f $tempfile ]; then
  rm -f $tempfile
fi

if [ $html = 1 ]; then
  echo "<html>" >$tempfile
  echo "<title> Dependencies </title>" >>$tempfile
  echo "<body>" >>$tempfile
fi

for arg in $args; do
  echo "Searching for dependencies of $arg"
  find_deps $arg
done

if [ $html = 1 ]; then
  echo "</body>" >> $tempfile
  echo "</html>" >> $tempfile
fi

if [ "$outfile" != "" ]; then
  cp $tempfile $outfile
  rm -f $tempfile
else
  cat $tempfile
fi

